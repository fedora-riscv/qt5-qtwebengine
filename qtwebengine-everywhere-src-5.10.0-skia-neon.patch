diff -Nur qtwebengine-everywhere-src-5.10.0/src/3rdparty/chromium/skia/BUILD.gn qtwebengine-everywhere-src-5.10.0-skia-neon/src/3rdparty/chromium/skia/BUILD.gn
--- qtwebengine-everywhere-src-5.10.0/src/3rdparty/chromium/skia/BUILD.gn	2017-11-28 14:06:53.000000000 +0100
+++ qtwebengine-everywhere-src-5.10.0-skia-neon/src/3rdparty/chromium/skia/BUILD.gn	2017-12-25 18:31:12.288797893 +0100
@@ -508,6 +508,24 @@
 }
 
 # Separated out so it can be compiled with different flags for SSE.
+if (current_cpu == "arm" && (arm_use_neon || arm_optionally_use_neon)) {
+  source_set("skia_opts_neon") {
+    sources = skia_opts.neon_sources
+    # Root build config sets -mfpu=$arm_fpu, which we expect to be neon
+    # when running this.
+    if (!arm_use_neon) {
+      configs -= [ "//build/config/compiler:compiler_arm_fpu" ]
+      cflags = [ "-mfpu=neon" ]
+    }
+    visibility = [ ":skia_opts" ]
+    configs -= [ "//build/config/compiler:chromium_code" ]
+    configs += [
+      ":skia_config",
+      ":skia_library_config",
+      "//build/config/compiler:no_chromium_code",
+    ]
+  }
+}
 if (current_cpu == "arm64") {
   source_set("skia_opts_crc32") {
     sources = skia_opts.crc32_sources
@@ -644,14 +662,7 @@
     if (arm_version >= 7) {
       sources = skia_opts.armv7_sources
       if (arm_use_neon || arm_optionally_use_neon) {
-        sources += skia_opts.neon_sources
-
-        # Root build config sets -mfpu=$arm_fpu, which we expect to be neon
-        # when running this.
-        if (!arm_use_neon) {
-          configs -= [ "//build/config/compiler:compiler_arm_fpu" ]
-          cflags += [ "-mfpu=neon" ]
-        }
+        deps += [ ":skia_opts_neon" ]
       }
     } else {
       sources = skia_opts.none_sources
diff -Nur qtwebengine-everywhere-src-5.10.0/src/3rdparty/chromium/third_party/skia/gn/opts.gni qtwebengine-everywhere-src-5.10.0-skia-neon/src/3rdparty/chromium/third_party/skia/gn/opts.gni
--- qtwebengine-everywhere-src-5.10.0/src/3rdparty/chromium/third_party/skia/gn/opts.gni	2017-11-28 14:06:53.000000000 +0100
+++ qtwebengine-everywhere-src-5.10.0-skia-neon/src/3rdparty/chromium/third_party/skia/gn/opts.gni	2017-12-25 18:29:15.083480322 +0100
@@ -23,6 +23,7 @@
   "$_src/opts/SkBitmapProcState_matrixProcs_neon.cpp",
   "$_src/opts/SkBlitMask_opts_arm_neon.cpp",
   "$_src/opts/SkBlitRow_opts_arm_neon.cpp",
+  "$_src/opts/SkOpts_neon.cpp",
 ]
 
 arm64 = [
@@ -33,6 +34,7 @@
   "$_src/opts/SkBlitMask_opts_arm_neon.cpp",
   "$_src/opts/SkBlitRow_opts_arm.cpp",
   "$_src/opts/SkBlitRow_opts_arm_neon.cpp",
+  "$_src/opts/SkOpts_neon.cpp",
 ]
 
 crc32 = [ "$_src/opts/SkOpts_crc32.cpp" ]
diff -Nur qtwebengine-everywhere-src-5.10.0/src/3rdparty/chromium/third_party/skia/src/core/SkBitmapProcState.cpp qtwebengine-everywhere-src-5.10.0-skia-neon/src/3rdparty/chromium/third_party/skia/src/core/SkBitmapProcState.cpp
--- qtwebengine-everywhere-src-5.10.0/src/3rdparty/chromium/third_party/skia/src/core/SkBitmapProcState.cpp	2017-11-28 14:06:53.000000000 +0100
+++ qtwebengine-everywhere-src-5.10.0-skia-neon/src/3rdparty/chromium/third_party/skia/src/core/SkBitmapProcState.cpp	2017-12-25 18:29:22.449374588 +0100
@@ -17,7 +17,7 @@
 #include "SkImageEncoder.h"
 #include "SkResourceCache.h"
 
-#if defined(SK_ARM_HAS_NEON)
+#if !SK_ARM_NEON_IS_NONE
 // These are defined in src/opts/SkBitmapProcState_arm_neon.cpp
 extern const SkBitmapProcState::SampleProc32 gSkBitmapProcStateSample32_neon[];
 #endif
@@ -212,7 +212,7 @@
             index |= 4;
         }
 
-#if !defined(SK_ARM_HAS_NEON)
+#if !SK_ARM_NEON_IS_ALWAYS
         static const SampleProc32 gSkBitmapProcStateSample32[] = {
             S32_opaque_D32_nofilter_DXDY,
             S32_alpha_D32_nofilter_DXDY,
diff -Nur qtwebengine-everywhere-src-5.10.0/src/3rdparty/chromium/third_party/skia/src/core/SkBitmapProcState_matrixProcs.cpp qtwebengine-everywhere-src-5.10.0-skia-neon/src/3rdparty/chromium/third_party/skia/src/core/SkBitmapProcState_matrixProcs.cpp
--- qtwebengine-everywhere-src-5.10.0/src/3rdparty/chromium/third_party/skia/src/core/SkBitmapProcState_matrixProcs.cpp	2017-11-28 14:06:53.000000000 +0100
+++ qtwebengine-everywhere-src-5.10.0-skia-neon/src/3rdparty/chromium/third_party/skia/src/core/SkBitmapProcState_matrixProcs.cpp	2017-12-25 18:34:09.229257992 +0100
@@ -46,16 +46,16 @@
 ///////////////////////////////////////////////////////////////////////////////
 
 // Compile neon code paths if needed
-#if defined(SK_ARM_HAS_NEON)
+#if !SK_ARM_NEON_IS_NONE
 
 // These are defined in src/opts/SkBitmapProcState_matrixProcs_neon.cpp
 extern const SkBitmapProcState::MatrixProc ClampX_ClampY_Procs_neon[];
 extern const SkBitmapProcState::MatrixProc RepeatX_RepeatY_Procs_neon[];
 
-#endif // defined(SK_ARM_HAS_NEON)
+#endif // !SK_ARM_NEON_IS_NONE
 
 // Compile non-neon code path if needed
-#if !defined(SK_ARM_HAS_NEON)
+#if !SK_ARM_NEON_IS_ALWAYS
 #define MAKENAME(suffix)         ClampX_ClampY ## suffix
 #define TILEX_PROCF(fx, max)     SkClampMax((fx) >> 16, max)
 #define TILEY_PROCF(fy, max)     SkClampMax((fy) >> 16, max)
diff -Nur qtwebengine-everywhere-src-5.10.0/src/3rdparty/chromium/third_party/skia/src/core/SkCpu.cpp qtwebengine-everywhere-src-5.10.0-skia-neon/src/3rdparty/chromium/third_party/skia/src/core/SkCpu.cpp
--- qtwebengine-everywhere-src-5.10.0/src/3rdparty/chromium/third_party/skia/src/core/SkCpu.cpp	2017-11-28 14:06:53.000000000 +0100
+++ qtwebengine-everywhere-src-5.10.0-skia-neon/src/3rdparty/chromium/third_party/skia/src/core/SkCpu.cpp	2017-12-25 18:37:45.974144769 +0100
@@ -74,6 +74,124 @@
         return features;
     }
 
+#elif defined(SK_CPU_ARM32)         && \
+      !defined(SK_BUILD_FOR_ANDROID)
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <pthread.h>
+
+    static uint32_t read_cpu_features() {
+        uint32_t features = 0;
+
+        // If we fail any of the following, assume we don't have NEON/VFPv4 instructions
+        // This allows us to return immediately in case of error.
+        bool have_neon = false;
+        bool have_vfpv4 = false;
+
+        // There is no user-accessible CPUID instruction on ARM that we can use.
+        // Instead, we must parse /proc/cpuinfo and look for the 'neon' feature.
+        // For example, here's a typical output (Nexus S running ICS 4.0.3):
+        /*
+        Processor       : ARMv7 Processor rev 2 (v7l)
+        BogoMIPS        : 994.65
+        Features        : swp half thumb fastmult vfp edsp thumbee neon vfpv3
+        CPU implementer : 0x41
+        CPU architecture: 7
+        CPU variant     : 0x2
+        CPU part        : 0xc08
+        CPU revision    : 2
+
+        Hardware        : herring
+        Revision        : 000b
+        Serial          : 3833c77d6dc000ec
+        */
+        char   buffer[4096];
+
+        do {
+            // open /proc/cpuinfo
+            int fd = TEMP_FAILURE_RETRY(open("/proc/cpuinfo", O_RDONLY));
+            if (fd < 0) {
+                SkDebugf("Could not open /proc/cpuinfo: %s\n", strerror(errno));
+                break;
+            }
+
+            // Read the file. To simplify our search, we're going to place two
+            // sentinel '\n' characters: one at the start of the buffer, and one at
+            // the end. This means we reserve the first and last buffer bytes.
+            buffer[0] = '\n';
+            int size = TEMP_FAILURE_RETRY(read(fd, buffer+1, sizeof(buffer)-2));
+            close(fd);
+
+            if (size < 0) {  // should not happen
+                SkDebugf("Could not read /proc/cpuinfo: %s\n", strerror(errno));
+                break;
+            }
+
+            SkDebugf("START /proc/cpuinfo:\n%.*s\nEND /proc/cpuinfo\n",
+                    size, buffer+1);
+
+            // Compute buffer limit, and place final sentinel
+            char* buffer_end = buffer + 1 + size;
+            buffer_end[0] = '\n';
+
+            // Now, find a line that starts with "Features", i.e. look for
+            // '\nFeatures ' in our buffer.
+            const char features[] = "\nFeatures\t";
+            const size_t features_len = sizeof(features)-1;
+
+            char*  line = (char*) memmem(buffer, buffer_end - buffer,
+                                        features, features_len);
+            if (line == nullptr) {  // Weird, no Features line, bad kernel?
+                SkDebugf("Could not find a line starting with 'Features'"
+                "in /proc/cpuinfo ?\n");
+                break;
+            }
+
+            line += features_len;  // Skip the "\nFeatures\t" prefix
+
+            // Find the end of the current line
+            char* line_end = (char*) memchr(line, '\n', buffer_end - line);
+            if (line_end == nullptr)
+                line_end = buffer_end;
+
+            // Now find an instance of 'neon' in the flags list. We want to
+            // ensure it's only 'neon' and not something fancy like 'noneon'
+            // so check that it follows a space.
+            const char neon[] = " neon";
+            const size_t neon_len = sizeof(neon)-1;
+            const char* flag = (const char*) memmem(line, line_end - line,
+                                                    neon, neon_len);
+            // Ensure it is followed by a space or a newline.
+            if (flag != nullptr
+                && (flag[neon_len] == ' ' || flag[neon_len] == '\n')) {
+                // Fine, we support Arm NEON !
+                have_neon = true;
+            }
+
+            // Now find an instance of 'vfpv4' in the flags list. We want to
+            // ensure it's only 'vfpv4' and not something fancy like 'novfpv4'
+            // so check that it follows a space.
+            const char vfpv4[] = " vfpv4";
+            const size_t vfpv4_len = sizeof(vfpv4)-1;
+            const char* vflag = (const char*) memmem(line, line_end - line,
+                                                     vfpv4, vfpv4_len);
+            // Ensure it is followed by a space or a newline.
+            if (vflag != nullptr
+                && (vflag[vfpv4_len] == ' ' || vflag[vfpv4_len] == '\n')) {
+                // Fine, we support Arm VFPv4 !
+                have_vfpv4 = true;
+            }
+
+        } while (0);
+
+        if (have_neon)               { features |= SkCpu::NEON    ; }
+        if (have_neon && have_vfpv4) { features |= SkCpu::NEON_FMA; }
+        if (have_vfpv4)              { features |= SkCpu::VFP_FP16; }
+        return features;
+    }
+
 #elif defined(SK_CPU_ARM64) && __has_include(<sys/auxv.h>)
     #include <sys/auxv.h>
 
diff -Nur qtwebengine-everywhere-src-5.10.0/src/3rdparty/chromium/third_party/skia/src/core/SkOpts.cpp qtwebengine-everywhere-src-5.10.0-skia-neon/src/3rdparty/chromium/third_party/skia/src/core/SkOpts.cpp
--- qtwebengine-everywhere-src-5.10.0/src/3rdparty/chromium/third_party/skia/src/core/SkOpts.cpp	2017-11-28 14:06:53.000000000 +0100
+++ qtwebengine-everywhere-src-5.10.0-skia-neon/src/3rdparty/chromium/third_party/skia/src/core/SkOpts.cpp	2017-12-25 18:34:52.777632875 +0100
@@ -95,6 +95,7 @@
     void Init_sse42();
     void Init_avx();
     void Init_crc32();
+    void Init_neon();
 
     static void init() {
 #if !defined(SK_BUILD_NO_OPTS)
@@ -104,6 +105,9 @@
         if (SkCpu::Supports(SkCpu::SSE42)) { Init_sse42(); }
         if (SkCpu::Supports(SkCpu::AVX  )) { Init_avx();   }
 
+    #elif defined(SK_CPU_ARM32)
+        if (SkCpu::Supports(SkCpu::NEON))  { Init_neon(); }
+
     #elif defined(SK_CPU_ARM64)
         if (SkCpu::Supports(SkCpu::CRC32)) { Init_crc32(); }
 
diff -Nur qtwebengine-everywhere-src-5.10.0/src/3rdparty/chromium/third_party/skia/src/core/SkUtilsArm.h qtwebengine-everywhere-src-5.10.0-skia-neon/src/3rdparty/chromium/third_party/skia/src/core/SkUtilsArm.h
--- qtwebengine-everywhere-src-5.10.0/src/3rdparty/chromium/third_party/skia/src/core/SkUtilsArm.h	2017-11-28 14:06:53.000000000 +0100
+++ qtwebengine-everywhere-src-5.10.0-skia-neon/src/3rdparty/chromium/third_party/skia/src/core/SkUtilsArm.h	2017-12-25 18:34:52.777632875 +0100
@@ -8,12 +8,75 @@
 #ifndef SkUtilsArm_DEFINED
 #define SkUtilsArm_DEFINED
 
-#include "SkTypes.h"
+#include "SkCpu.h"
+#include "SkUtils.h"
 
-#if defined(SK_ARM_HAS_NEON)
-    #define SK_ARM_NEON_WRAP(x) (x ## _neon)
+// Define SK_ARM_NEON_MODE to one of the following values
+// corresponding respectively to:
+// - No ARM Neon support at all  (not targetting ARMv7-A, or don't have NEON)
+// - Full ARM Neon support (i.e. assume the CPU always supports it)
+// - Optional ARM Neon support (i.e. probe CPU at runtime)
+//
+#define SK_ARM_NEON_MODE_NONE     0
+#define SK_ARM_NEON_MODE_ALWAYS   1
+#define SK_ARM_NEON_MODE_DYNAMIC  2
+
+#if defined(SK_ARM_HAS_OPTIONAL_NEON)
+#  define SK_ARM_NEON_MODE  SK_ARM_NEON_MODE_DYNAMIC
+#elif defined(SK_ARM_HAS_NEON)
+#  define SK_ARM_NEON_MODE  SK_ARM_NEON_MODE_ALWAYS
+#else
+#  define SK_ARM_NEON_MODE  SK_ARM_NEON_MODE_NONE
+#endif
+
+// Convenience test macros, always defined as 0 or 1
+#define SK_ARM_NEON_IS_NONE    (SK_ARM_NEON_MODE == SK_ARM_NEON_MODE_NONE)
+#define SK_ARM_NEON_IS_ALWAYS  (SK_ARM_NEON_MODE == SK_ARM_NEON_MODE_ALWAYS)
+#define SK_ARM_NEON_IS_DYNAMIC (SK_ARM_NEON_MODE == SK_ARM_NEON_MODE_DYNAMIC)
+
+// The sk_cpu_arm_has_neon() function returns true iff the target device
+// is ARMv7-A and supports Neon instructions. In DYNAMIC mode, this actually
+// probes the CPU at runtime (and caches the result).
+
+static inline bool sk_cpu_arm_has_neon(void) {
+#if SK_ARM_NEON_IS_NONE
+    return false;
 #else
-    #define SK_ARM_NEON_WRAP(x) (x)
+    return SkCpu::Supports(SkCpu::NEON);
+#endif
+}
+
+// Use SK_ARM_NEON_WRAP(symbol) to map 'symbol' to a NEON-specific symbol
+// when applicable. This will transform 'symbol' differently depending on
+// the current NEON configuration, i.e.:
+//
+//    NONE           -> 'symbol'
+//    ALWAYS         -> 'symbol_neon'
+//    DYNAMIC        -> 'symbol' or 'symbol_neon' depending on runtime check.
+//
+// The goal is to simplify user code, for example:
+//
+//      return SK_ARM_NEON_WRAP(do_something)(params);
+//
+// Replaces the equivalent:
+//
+//     #if SK_ARM_NEON_IS_NONE
+//       return do_something(params);
+//     #elif SK_ARM_NEON_IS_ALWAYS
+//       return do_something_neon(params);
+//     #elif SK_ARM_NEON_IS_DYNAMIC
+//       if (sk_cpu_arm_has_neon())
+//         return do_something_neon(params);
+//       else
+//         return do_something(params);
+//     #endif
+//
+#if SK_ARM_NEON_IS_NONE
+#  define SK_ARM_NEON_WRAP(x)   (x)
+#elif SK_ARM_NEON_IS_ALWAYS
+#  define SK_ARM_NEON_WRAP(x)   (x ## _neon)
+#elif SK_ARM_NEON_IS_DYNAMIC
+#  define SK_ARM_NEON_WRAP(x)   (sk_cpu_arm_has_neon() ? x ## _neon : x)
 #endif
 
 #endif // SkUtilsArm_DEFINED
diff -Nur qtwebengine-everywhere-src-5.10.0/src/3rdparty/chromium/third_party/skia/src/opts/SkOpts_neon.cpp qtwebengine-everywhere-src-5.10.0-skia-neon/src/3rdparty/chromium/third_party/skia/src/opts/SkOpts_neon.cpp
--- qtwebengine-everywhere-src-5.10.0/src/3rdparty/chromium/third_party/skia/src/opts/SkOpts_neon.cpp	1970-01-01 01:00:00.000000000 +0100
+++ qtwebengine-everywhere-src-5.10.0-skia-neon/src/3rdparty/chromium/third_party/skia/src/opts/SkOpts_neon.cpp	2017-12-26 01:45:00.514114716 +0100
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2015 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "SkOpts.h"
+
+#define SK_OPTS_NS sk_neon
+#include "SkBlitMask_opts.h"
+#include "SkBlitRow_opts.h"
+#include "SkBlurImageFilter_opts.h"
+#include "SkMorphologyImageFilter_opts.h"
+#include "SkSwizzler_opts.h"
+#include "SkXfermode_opts.h"
+
+namespace SkOpts {
+    void Init_neon() {
+        create_xfermode = sk_neon::create_xfermode;
+
+        box_blur_xx = sk_neon::box_blur_xx;
+        box_blur_xy = sk_neon::box_blur_xy;
+        box_blur_yx = sk_neon::box_blur_yx;
+
+        dilate_x = sk_neon::dilate_x;
+        dilate_y = sk_neon::dilate_y;
+         erode_x = sk_neon::erode_x;
+         erode_y = sk_neon::erode_y;
+
+        blit_mask_d32_a8 = sk_neon::blit_mask_d32_a8;
+
+        blit_row_color32     = sk_neon::blit_row_color32;
+        blit_row_s32a_opaque = sk_neon::blit_row_s32a_opaque;
+
+        RGBA_to_BGRA          = sk_neon::RGBA_to_BGRA;
+        RGBA_to_rgbA          = sk_neon::RGBA_to_rgbA;
+        RGBA_to_bgrA          = sk_neon::RGBA_to_bgrA;
+        RGB_to_RGB1           = sk_neon::RGB_to_RGB1;
+        RGB_to_BGR1           = sk_neon::RGB_to_BGR1;
+        gray_to_RGB1          = sk_neon::gray_to_RGB1;
+        grayA_to_RGBA         = sk_neon::grayA_to_RGBA;
+        grayA_to_rgbA         = sk_neon::grayA_to_rgbA;
+        inverted_CMYK_to_RGB1 = sk_neon::inverted_CMYK_to_RGB1;
+        inverted_CMYK_to_BGR1 = sk_neon::inverted_CMYK_to_BGR1;
+    }
+}
