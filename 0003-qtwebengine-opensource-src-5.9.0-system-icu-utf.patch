From dff1d03d1c4936183c46ff13f2bbd65901cf4ebb Mon Sep 17 00:00:00 2001
From: Helio Chissini de Castro <helio@kde.org>
Date: Wed, 31 May 2017 11:16:12 +0200
Subject: [PATCH] qtwebengine-opensource-src-5.9.0-system-icu-utf

---
 src/3rdparty/chromium/base/BUILD.gn                |  4 +--
 src/3rdparty/chromium/base/files/file_path.cc      |  6 ++---
 src/3rdparty/chromium/base/json/json_parser.cc     | 28 ++++++++++----------
 src/3rdparty/chromium/base/json/string_escape.cc   |  2 +-
 src/3rdparty/chromium/base/strings/pattern.cc      | 21 ++++++++-------
 src/3rdparty/chromium/base/strings/string_split.cc |  2 +-
 src/3rdparty/chromium/base/strings/string_util.cc  | 12 ++++-----
 .../base/strings/utf_string_conversion_utils.cc    | 28 ++++++++++----------
 .../chromium/base/third_party/icu/icu_utf.cc       | 30 +++++++++++-----------
 .../browser/devtools/devtools_io_context.cc        |  4 +--
 .../chromium/net/cert/internal/parse_name.cc       |  6 ++---
 .../chromium/tools/gn/bootstrap/bootstrap.py       |  3 +++
 .../chromium/ui/base/ime/input_method_chromeos.cc  |  2 +-
 src/3rdparty/chromium/ui/gfx/utf16_indexing.cc     |  4 +--
 14 files changed, 77 insertions(+), 75 deletions(-)

diff --git a/src/3rdparty/chromium/base/BUILD.gn b/src/3rdparty/chromium/base/BUILD.gn
index 66f2be1ff..a7d384ca4 100644
--- a/src/3rdparty/chromium/base/BUILD.gn
+++ b/src/3rdparty/chromium/base/BUILD.gn
@@ -831,8 +831,6 @@ component("base") {
     "third_party/dmg_fp/dmg_fp.h",
     "third_party/dmg_fp/dtoa_wrapper.cc",
     "third_party/dmg_fp/g_fmt.cc",
-    "third_party/icu/icu_utf.cc",
-    "third_party/icu/icu_utf.h",
     "third_party/superfasthash/superfasthash.c",
     "threading/non_thread_safe.h",
     "threading/non_thread_safe_impl.cc",
@@ -1357,6 +1355,8 @@ component("base") {
       linux_configs += [ "//build/config/linux:glib" ]
     }
 
+    libs += [ "icu18n" ]
+
     defines += [ "USE_SYMBOLIZE" ]
 
     configs += linux_configs
diff --git a/src/3rdparty/chromium/base/files/file_path.cc b/src/3rdparty/chromium/base/files/file_path.cc
index cff862ae1..b17b46e5f 100644
--- a/src/3rdparty/chromium/base/files/file_path.cc
+++ b/src/3rdparty/chromium/base/files/file_path.cc
@@ -18,7 +18,7 @@
 
 #if defined(OS_MACOSX)
 #include "base/mac/scoped_cftyperef.h"
-#include "base/third_party/icu/icu_utf.h"
+#include <unicode/utf.h>
 #endif
 
 #if defined(OS_WIN)
@@ -1156,9 +1156,9 @@ inline int HFSReadNextNonIgnorableCodepoint(const char* string,
                                             int* index) {
   int codepoint = 0;
   while (*index < length && codepoint == 0) {
-    // CBU8_NEXT returns a value < 0 in error cases. For purposes of string
+    // U8_NEXT returns a value < 0 in error cases. For purposes of string
     // comparison, we just use that value and flag it with DCHECK.
-    CBU8_NEXT(string, *index, length, codepoint);
+    U8_NEXT(string, *index, length, codepoint);
     DCHECK_GT(codepoint, 0);
     if (codepoint > 0) {
       // Check if there is a subtable for this upper byte.
diff --git a/src/3rdparty/chromium/base/json/json_parser.cc b/src/3rdparty/chromium/base/json/json_parser.cc
index cd427da9e..82ff9773c 100644
--- a/src/3rdparty/chromium/base/json/json_parser.cc
+++ b/src/3rdparty/chromium/base/json/json_parser.cc
@@ -16,7 +16,7 @@
 #include "base/strings/stringprintf.h"
 #include "base/strings/utf_string_conversion_utils.h"
 #include "base/strings/utf_string_conversions.h"
-#include "base/third_party/icu/icu_utf.h"
+#include <unicode/utf.h>
 #include "base/values.h"
 
 namespace base {
@@ -630,21 +630,21 @@ bool JSONParser::ConsumeStringRaw(StringBuilder* out) {
 
   while (CanConsume(1)) {
     int start_index = index_;
-    pos_ = start_pos_ + index_;  // CBU8_NEXT is postcrement.
-    CBU8_NEXT(start_pos_, index_, length, next_char);
+    pos_ = start_pos_ + index_;  // U8_NEXT is postcrement.
+    U8_NEXT(start_pos_, index_, length, next_char);
     if (next_char < 0 || !IsValidCharacter(next_char)) {
       if ((options_ & JSON_REPLACE_INVALID_CHARACTERS) == 0) {
         ReportError(JSONReader::JSON_UNSUPPORTED_ENCODING, 1);
         return false;
       }
-      CBU8_NEXT(start_pos_, start_index, length, next_char);
+      U8_NEXT(start_pos_, start_index, length, next_char);
       string.Convert();
       string.AppendString(kUnicodeReplacementString);
       continue;
     }
 
     if (next_char == '"') {
-      --index_;  // Rewind by one because of CBU8_NEXT.
+      --index_;  // Rewind by one because of U8_NEXT.
       out->Swap(&string);
       return true;
     }
@@ -774,10 +774,10 @@ bool JSONParser::DecodeUTF16(std::string* dest_string) {
 
   // If this is a high surrogate, consume the next code unit to get the
   // low surrogate.
-  if (CBU16_IS_SURROGATE(code_unit16_high)) {
+  if (U16_IS_SURROGATE(code_unit16_high)) {
     // Make sure this is the high surrogate. If not, it's an encoding
     // error.
-    if (!CBU16_IS_SURROGATE_LEAD(code_unit16_high))
+    if (!U16_IS_SURROGATE_LEAD(code_unit16_high))
       return false;
 
     // Make sure that the token has more characters to consume the
@@ -794,24 +794,24 @@ bool JSONParser::DecodeUTF16(std::string* dest_string) {
 
     NextNChars(3);
 
-    if (!CBU16_IS_TRAIL(code_unit16_low)) {
+    if (!U16_IS_TRAIL(code_unit16_low)) {
       return false;
     }
 
     uint32_t code_point =
-        CBU16_GET_SUPPLEMENTARY(code_unit16_high, code_unit16_low);
+        U16_GET_SUPPLEMENTARY(code_unit16_high, code_unit16_low);
     if (!IsValidCharacter(code_point))
       return false;
 
     offset = 0;
-    CBU8_APPEND_UNSAFE(code_unit8, offset, code_point);
+    U8_APPEND_UNSAFE(code_unit8, offset, code_point);
   } else {
     // Not a surrogate.
-    DCHECK(CBU16_IS_SINGLE(code_unit16_high));
+    DCHECK(U16_IS_SINGLE(code_unit16_high));
     if (!IsValidCharacter(code_unit16_high))
       return false;
 
-    CBU8_APPEND_UNSAFE(code_unit8, offset, code_unit16_high);
+    U8_APPEND_UNSAFE(code_unit8, offset, code_unit16_high);
   }
 
   dest_string->append(code_unit8);
@@ -828,9 +828,9 @@ void JSONParser::DecodeUTF8(const int32_t& point, StringBuilder* dest) {
   } else {
     char utf8_units[4] = { 0 };
     int offset = 0;
-    CBU8_APPEND_UNSAFE(utf8_units, offset, point);
+    U8_APPEND_UNSAFE(utf8_units, offset, point);
     dest->Convert();
-    // CBU8_APPEND_UNSAFE can overwrite up to 4 bytes, so utf8_units may not be
+    // U8_APPEND_UNSAFE can overwrite up to 4 bytes, so utf8_units may not be
     // zero terminated at this point.  |offset| contains the correct length.
     dest->AppendString(std::string(utf8_units, offset));
   }
diff --git a/src/3rdparty/chromium/base/json/string_escape.cc b/src/3rdparty/chromium/base/json/string_escape.cc
index f67fa93bf..907b80a73 100644
--- a/src/3rdparty/chromium/base/json/string_escape.cc
+++ b/src/3rdparty/chromium/base/json/string_escape.cc
@@ -14,7 +14,7 @@
 #include "base/strings/stringprintf.h"
 #include "base/strings/utf_string_conversion_utils.h"
 #include "base/strings/utf_string_conversions.h"
-#include "base/third_party/icu/icu_utf.h"
+#include <unicode/utf.h>
 
 namespace base {
 
diff --git a/src/3rdparty/chromium/base/strings/pattern.cc b/src/3rdparty/chromium/base/strings/pattern.cc
index af30aab86..c4ce6fc86 100644
--- a/src/3rdparty/chromium/base/strings/pattern.cc
+++ b/src/3rdparty/chromium/base/strings/pattern.cc
@@ -3,14 +3,13 @@
 // found in the LICENSE file.
 
 #include "base/strings/pattern.h"
-
-#include "base/third_party/icu/icu_utf.h"
+#include <unicode/utf.h>
 
 namespace base {
 
 namespace {
 
-static bool IsWildcard(base_icu::UChar32 character) {
+static bool IsWildcard(UChar32 character) {
   return character == '*' || character == '?';
 }
 
@@ -37,9 +36,9 @@ static void EatSameChars(const CHAR** pattern, const CHAR* pattern_end,
     // Check if the chars match, if so, increment the ptrs.
     const CHAR* pattern_next = *pattern;
     const CHAR* string_next = *string;
-    base_icu::UChar32 pattern_char = next(&pattern_next, pattern_end);
+    UChar32 pattern_char = next(&pattern_next, pattern_end);
     if (pattern_char == next(&string_next, string_end) &&
-        pattern_char != CBU_SENTINEL) {
+        pattern_char != U_SENTINEL) {
       *pattern = pattern_next;
       *string = string_next;
     } else {
@@ -133,20 +132,20 @@ static bool MatchPatternT(const CHAR* eval, const CHAR* eval_end,
 }
 
 struct NextCharUTF8 {
-  base_icu::UChar32 operator()(const char** p, const char* end) {
-    base_icu::UChar32 c;
+  UChar32 operator()(const char** p, const char* end) {
+    UChar32 c;
     int offset = 0;
-    CBU8_NEXT(*p, offset, end - *p, c);
+    U8_NEXT(*p, offset, end - *p, c);
     *p += offset;
     return c;
   }
 };
 
 struct NextCharUTF16 {
-  base_icu::UChar32 operator()(const char16** p, const char16* end) {
-    base_icu::UChar32 c;
+  UChar32 operator()(const char16** p, const char16* end) {
+    UChar32 c;
     int offset = 0;
-    CBU16_NEXT(*p, offset, end - *p, c);
+    U16_NEXT(*p, offset, end - *p, c);
     *p += offset;
     return c;
   }
diff --git a/src/3rdparty/chromium/base/strings/string_split.cc b/src/3rdparty/chromium/base/strings/string_split.cc
index a8180b24d..ac771a0f0 100644
--- a/src/3rdparty/chromium/base/strings/string_split.cc
+++ b/src/3rdparty/chromium/base/strings/string_split.cc
@@ -8,7 +8,7 @@
 
 #include "base/logging.h"
 #include "base/strings/string_util.h"
-#include "base/third_party/icu/icu_utf.h"
+#include <unicode/utf.h>
 
 namespace base {
 
diff --git a/src/3rdparty/chromium/base/strings/string_util.cc b/src/3rdparty/chromium/base/strings/string_util.cc
index cb668ed7f..c57ccf391 100644
--- a/src/3rdparty/chromium/base/strings/string_util.cc
+++ b/src/3rdparty/chromium/base/strings/string_util.cc
@@ -25,7 +25,7 @@
 #include "base/memory/singleton.h"
 #include "base/strings/utf_string_conversion_utils.h"
 #include "base/strings/utf_string_conversions.h"
-#include "base/third_party/icu/icu_utf.h"
+#include <unicode/utf.h>
 #include "build/build_config.h"
 
 namespace base {
@@ -357,19 +357,19 @@ void TruncateUTF8ToByteSize(const std::string& input,
   }
   DCHECK_LE(byte_size,
             static_cast<uint32_t>(std::numeric_limits<int32_t>::max()));
-  // Note: This cast is necessary because CBU8_NEXT uses int32_ts.
+  // Note: This cast is necessary because U8_NEXT uses int32_ts.
   int32_t truncation_length = static_cast<int32_t>(byte_size);
   int32_t char_index = truncation_length - 1;
   const char* data = input.data();
 
-  // Using CBU8, we will move backwards from the truncation point
+  // Using U8, we will move backwards from the truncation point
   // to the beginning of the string looking for a valid UTF8
   // character.  Once a full UTF8 character is found, we will
   // truncate the string to the end of that character.
   while (char_index >= 0) {
     int32_t prev = char_index;
-    base_icu::UChar32 code_point = 0;
-    CBU8_NEXT(data, char_index, truncation_length, code_point);
+    UChar32 code_point = 0;
+    U8_NEXT(data, char_index, truncation_length, code_point);
     if (!IsValidCharacter(code_point) ||
         !IsValidCodepoint(code_point)) {
       char_index = prev - 1;
@@ -522,7 +522,7 @@ bool IsStringUTF8(const StringPiece& str) {
 
   while (char_index < src_len) {
     int32_t code_point;
-    CBU8_NEXT(src, char_index, src_len, code_point);
+    U8_NEXT(src, char_index, src_len, code_point);
     if (!IsValidCharacter(code_point))
       return false;
   }
diff --git a/src/3rdparty/chromium/base/strings/utf_string_conversion_utils.cc b/src/3rdparty/chromium/base/strings/utf_string_conversion_utils.cc
index 3101a6028..7f7d84b3c 100644
--- a/src/3rdparty/chromium/base/strings/utf_string_conversion_utils.cc
+++ b/src/3rdparty/chromium/base/strings/utf_string_conversion_utils.cc
@@ -4,7 +4,7 @@
 
 #include "base/strings/utf_string_conversion_utils.h"
 
-#include "base/third_party/icu/icu_utf.h"
+#include <unicode/utf.h>
 
 namespace base {
 
@@ -18,7 +18,7 @@ bool ReadUnicodeCharacter(const char* src,
   // use a signed type for code_point.  But this function returns false
   // on error anyway, so code_point_out is unsigned.
   int32_t code_point;
-  CBU8_NEXT(src, *char_index, src_len, code_point);
+  U8_NEXT(src, *char_index, src_len, code_point);
   *code_point_out = static_cast<uint32_t>(code_point);
 
   // The ICU macro above moves to the next char, we want to point to the last
@@ -33,16 +33,16 @@ bool ReadUnicodeCharacter(const char16* src,
                           int32_t src_len,
                           int32_t* char_index,
                           uint32_t* code_point) {
-  if (CBU16_IS_SURROGATE(src[*char_index])) {
-    if (!CBU16_IS_SURROGATE_LEAD(src[*char_index]) ||
+  if (U16_IS_SURROGATE(src[*char_index])) {
+    if (!U16_IS_SURROGATE_LEAD(src[*char_index]) ||
         *char_index + 1 >= src_len ||
-        !CBU16_IS_TRAIL(src[*char_index + 1])) {
+        !U16_IS_TRAIL(src[*char_index + 1])) {
       // Invalid surrogate pair.
       return false;
     }
 
     // Valid surrogate pair.
-    *code_point = CBU16_GET_SUPPLEMENTARY(src[*char_index],
+    *code_point = U16_GET_SUPPLEMENTARY(src[*char_index],
                                           src[*char_index + 1]);
     (*char_index)++;
   } else {
@@ -76,30 +76,30 @@ size_t WriteUnicodeCharacter(uint32_t code_point, std::string* output) {
   }
 
 
-  // CBU8_APPEND_UNSAFE can append up to 4 bytes.
+  // U8_APPEND_UNSAFE can append up to 4 bytes.
   size_t char_offset = output->length();
   size_t original_char_offset = char_offset;
-  output->resize(char_offset + CBU8_MAX_LENGTH);
+  output->resize(char_offset + U8_MAX_LENGTH);
 
-  CBU8_APPEND_UNSAFE(&(*output)[0], char_offset, code_point);
+  U8_APPEND_UNSAFE(&(*output)[0], char_offset, code_point);
 
-  // CBU8_APPEND_UNSAFE will advance our pointer past the inserted character, so
+  // U8_APPEND_UNSAFE will advance our pointer past the inserted character, so
   // it will represent the new length of the string.
   output->resize(char_offset);
   return char_offset - original_char_offset;
 }
 
 size_t WriteUnicodeCharacter(uint32_t code_point, string16* output) {
-  if (CBU16_LENGTH(code_point) == 1) {
+  if (U16_LENGTH(code_point) == 1) {
     // Thie code point is in the Basic Multilingual Plane (BMP).
     output->push_back(static_cast<char16>(code_point));
     return 1;
   }
   // Non-BMP characters use a double-character encoding.
   size_t char_offset = output->length();
-  output->resize(char_offset + CBU16_MAX_LENGTH);
-  CBU16_APPEND_UNSAFE(&(*output)[0], char_offset, code_point);
-  return CBU16_MAX_LENGTH;
+  output->resize(char_offset + U16_MAX_LENGTH);
+  U16_APPEND_UNSAFE(&(*output)[0], char_offset, code_point);
+  return U16_MAX_LENGTH;
 }
 
 // Generalized Unicode converter -----------------------------------------------
diff --git a/src/3rdparty/chromium/base/third_party/icu/icu_utf.cc b/src/3rdparty/chromium/base/third_party/icu/icu_utf.cc
index 2b67c5d9c..7ca6a6e0f 100644
--- a/src/3rdparty/chromium/base/third_party/icu/icu_utf.cc
+++ b/src/3rdparty/chromium/base/third_party/icu/icu_utf.cc
@@ -17,7 +17,7 @@
 *   that would otherwise be too long as macros.
 */
 
-#include "base/third_party/icu/icu_utf.h"
+#include <unicode/utf.h>
 
 namespace base_icu {
 
@@ -35,14 +35,14 @@ namespace base_icu {
  *
  * @deprecated ICU 2.4. Obsolete, see utf_old.h.
  */
-#define CBUTF8_ERROR_VALUE_1 0x15
+#define UTF8_ERROR_VALUE_1 0x15
 
 /**
  * See documentation on UTF8_ERROR_VALUE_1 for details.
  *
  * @deprecated ICU 2.4. Obsolete, see utf_old.h.
  */
-#define CBUTF8_ERROR_VALUE_2 0x9f
+#define UTF8_ERROR_VALUE_2 0x9f
 
 
 /**
@@ -51,7 +51,7 @@ namespace base_icu {
  *
  * @deprecated ICU 2.4. Obsolete, see utf_old.h.
  */
-#define CBUTF_ERROR_VALUE 0xffff
+#define UTF_ERROR_VALUE 0xffff
 
 /*
  * This table could be replaced on many machines by
@@ -103,7 +103,7 @@ utf8_minLegal[4]={ 0, 0x80, 0x800, 0x10000 };
 
 static const UChar32
 utf8_errorValue[6]={
-    CBUTF8_ERROR_VALUE_1, CBUTF8_ERROR_VALUE_2, CBUTF_ERROR_VALUE, 0x10ffff,
+    UTF8_ERROR_VALUE_1, UTF8_ERROR_VALUE_2, UTF_ERROR_VALUE, 0x10ffff,
     0x3ffffff, 0x7fffffff
 };
 
@@ -135,11 +135,11 @@ UChar32 utf8_nextCharSafeBody(const uint8_t* s,
                               UChar32 c,
                               UBool strict) {
   int32_t i = *pi;
-  uint8_t count = CBU8_COUNT_TRAIL_BYTES(c);
+  uint8_t count = U8_COUNT_TRAIL_BYTES(c);
     if((i)+count<=(length)) {
       uint8_t trail, illegal = 0;
 
-        CBU8_MASK_LEAD_BYTE((c), count);
+        U8_MASK_LEAD_BYTE((c), count);
         /* count==0 for illegally leading trail bytes and the illegal bytes 0xfe and 0xff */
         switch(count) {
         /* each branch falls through to the next one */
@@ -169,9 +169,9 @@ UChar32 utf8_nextCharSafeBody(const uint8_t* s,
             break;
         case 0:
             if(strict>=0) {
-                return CBUTF8_ERROR_VALUE_1;
+                return UTF8_ERROR_VALUE_1;
             } else {
-                return CBU_SENTINEL;
+                return U_SENTINEL;
             }
         /* no default branch to optimize switch()  - all values are covered */
         }
@@ -189,21 +189,21 @@ UChar32 utf8_nextCharSafeBody(const uint8_t* s,
 
         /* correct sequence - all trail bytes have (b7..b6)==(10)? */
         /* illegal is also set if count>=4 */
-        if(illegal || (c)<utf8_minLegal[count] || (CBU_IS_SURROGATE(c) && strict!=-2)) {
+        if(illegal || (c)<utf8_minLegal[count] || (U_IS_SURROGATE(c) && strict!=-2)) {
             /* error handling */
             uint8_t errorCount = count;
             /* don't go beyond this sequence */
             i=*pi;
-            while(count>0 && CBU8_IS_TRAIL(s[i])) {
+            while(count>0 && U8_IS_TRAIL(s[i])) {
                 ++(i);
                 --count;
             }
             if(strict>=0) {
                 c=utf8_errorValue[errorCount-count];
             } else {
-                c=CBU_SENTINEL;
+                c=U_SENTINEL;
             }
-        } else if((strict)>0 && CBU_IS_UNICODE_NONCHAR(c)) {
+        } else if((strict)>0 && U_IS_UNICODE_NONCHAR(c)) {
             /* strict: forbid non-characters like U+fffe */
             c=utf8_errorValue[count];
         }
@@ -211,13 +211,13 @@ UChar32 utf8_nextCharSafeBody(const uint8_t* s,
         /* error handling */
         int32_t i0 = i;
         /* don't just set (i)=(length) in case there is an illegal sequence */
-        while((i)<(length) && CBU8_IS_TRAIL(s[i])) {
+        while((i)<(length) && U8_IS_TRAIL(s[i])) {
             ++(i);
         }
         if(strict>=0) {
             c=utf8_errorValue[i-i0];
         } else {
-            c=CBU_SENTINEL;
+            c=U_SENTINEL;
         }
     }
     *pi=i;
diff --git a/src/3rdparty/chromium/content/browser/devtools/devtools_io_context.cc b/src/3rdparty/chromium/content/browser/devtools/devtools_io_context.cc
index 55f65f8c3..a7d616115 100644
--- a/src/3rdparty/chromium/content/browser/devtools/devtools_io_context.cc
+++ b/src/3rdparty/chromium/content/browser/devtools/devtools_io_context.cc
@@ -8,7 +8,7 @@
 #include "base/files/file_util.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/string_util.h"
-#include "base/third_party/icu/icu_utf.h"
+#include <unicode/utf.h>
 #include "content/public/browser/browser_thread.h"
 
 namespace content {
@@ -87,7 +87,7 @@ void Stream::ReadOnFileThread(off_t position, size_t max_size,
     } else {
       // Provided client has requested sufficient large block, make their
       // life easier by not truncating in the middle of a UTF-8 character.
-      if (size_got > 6 && !CBU8_IS_SINGLE(buffer[size_got - 1])) {
+      if (size_got > 6 && !U8_IS_SINGLE(buffer[size_got - 1])) {
         base::TruncateUTF8ToByteSize(buffer, size_got, &buffer);
         size_got = buffer.size();
       } else {
diff --git a/src/3rdparty/chromium/net/cert/internal/parse_name.cc b/src/3rdparty/chromium/net/cert/internal/parse_name.cc
index bb9b64051..5eaeb52d0 100644
--- a/src/3rdparty/chromium/net/cert/internal/parse_name.cc
+++ b/src/3rdparty/chromium/net/cert/internal/parse_name.cc
@@ -10,7 +10,7 @@
 #include "base/strings/utf_string_conversion_utils.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/sys_byteorder.h"
-#include "base/third_party/icu/icu_utf.h"
+#include <unicode/utf.h>
 
 namespace net {
 
@@ -35,7 +35,7 @@ bool ConvertBmpStringValue(const der::Input& in, std::string* out) {
 
     // BMPString only supports codepoints in the Basic Multilingual Plane;
     // surrogates are not allowed.
-    if (CBU_IS_SURROGATE(c))
+    if (U_IS_SURROGATE(c))
       return false;
   }
   return base::UTF16ToUTF8(in_16bit.data(), in_16bit.size(), out);
@@ -55,7 +55,7 @@ bool ConvertUniversalStringValue(const der::Input& in, std::string* out) {
   for (const uint32_t c : in_32bit) {
     // UniversalString is UCS-4 in big-endian order.
     uint32_t codepoint = base::NetToHost32(c);
-    if (!CBU_IS_UNICODE_CHAR(codepoint))
+    if (!U_IS_UNICODE_CHAR(codepoint))
       return false;
 
     base::WriteUnicodeCharacter(codepoint, out);
diff --git a/src/3rdparty/chromium/tools/gn/bootstrap/bootstrap.py b/src/3rdparty/chromium/tools/gn/bootstrap/bootstrap.py
index fc7efd80a..6dcec7f0e 100755
--- a/src/3rdparty/chromium/tools/gn/bootstrap/bootstrap.py
+++ b/src/3rdparty/chromium/tools/gn/bootstrap/bootstrap.py
@@ -579,6 +579,9 @@ def write_gn_ninja(path, root_gen_dir, options):
     libs.extend(['-lplds4'])
     libs.extend(['-lplc4'])
     libs.extend(['-lnspr4'])
+    libs.extend(['-licui18n'])
+    libs.extend(['-licuuc'])
+    libs.extend(['-licudata'])
 
     ldflags.extend(['-pthread'])
 
diff --git a/src/3rdparty/chromium/ui/base/ime/input_method_chromeos.cc b/src/3rdparty/chromium/ui/base/ime/input_method_chromeos.cc
index a8ac9028f..8fa5d2a64 100644
--- a/src/3rdparty/chromium/ui/base/ime/input_method_chromeos.cc
+++ b/src/3rdparty/chromium/ui/base/ime/input_method_chromeos.cc
@@ -17,7 +17,7 @@
 #include "base/strings/string_util.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/sys_info.h"
-#include "base/third_party/icu/icu_utf.h"
+#include <unicode/utf.h>
 #include "ui/base/ime/chromeos/ime_keyboard.h"
 #include "ui/base/ime/chromeos/input_method_manager.h"
 #include "ui/base/ime/composition_text.h"
diff --git a/src/3rdparty/chromium/ui/gfx/utf16_indexing.cc b/src/3rdparty/chromium/ui/gfx/utf16_indexing.cc
index c7f38de0d..08a0ff5fb 100644
--- a/src/3rdparty/chromium/ui/gfx/utf16_indexing.cc
+++ b/src/3rdparty/chromium/ui/gfx/utf16_indexing.cc
@@ -5,13 +5,13 @@
 #include "ui/gfx/utf16_indexing.h"
 
 #include "base/logging.h"
-#include "base/third_party/icu/icu_utf.h"
+#include <unicode/utf.h>
 
 namespace gfx {
 
 bool IsValidCodePointIndex(const base::string16& s, size_t index) {
   return index == 0 || index == s.length() ||
-    !(CBU16_IS_TRAIL(s[index]) && CBU16_IS_LEAD(s[index - 1]));
+    !(U16_IS_TRAIL(s[index]) && U16_IS_LEAD(s[index - 1]));
 }
 
 ptrdiff_t UTF16IndexToOffset(const base::string16& s, size_t base, size_t pos) {
-- 
2.13.0

