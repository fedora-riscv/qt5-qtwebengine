From 8bad8aac82444a9e1feda3f1a8b214b81be8a8fc Mon Sep 17 00:00:00 2001
From: Helio Chissini de Castro <helio@kde.org>
Date: Wed, 31 May 2017 15:02:52 +0200
Subject: [PATCH] qtwebengine-opensource-src-5.9.-openmax-dl-neon

---
 .../chromium/third_party/openmax_dl/dl/dl.gyp      |  9 ----
 .../third_party/openmax_dl/dl/sp/src/arm/detect.c  | 56 ++++++++++++++++++----
 2 files changed, 48 insertions(+), 17 deletions(-)

diff --git a/src/3rdparty/chromium/third_party/openmax_dl/dl/dl.gyp b/src/3rdparty/chromium/third_party/openmax_dl/dl/dl.gyp
index 2b0826fe1..20b4b1f35 100644
--- a/src/3rdparty/chromium/third_party/openmax_dl/dl/dl.gyp
+++ b/src/3rdparty/chromium/third_party/openmax_dl/dl/dl.gyp
@@ -219,15 +219,6 @@
           'conditions': [
             ['arm_neon_optional==1', {
               # Run-time NEON detection.
-              'dependencies': [
-                '../../../build/android/ndk.gyp:cpu_features',
-              ],
-              'link_settings' : {
-                'libraries': [
-                  # To get the __android_log_print routine
-                  '-llog',
-                ],
-              },
               'sources': [
                 # Detection routine
                 'sp/src/arm/detect.c',
diff --git a/src/3rdparty/chromium/third_party/openmax_dl/dl/sp/src/arm/detect.c b/src/3rdparty/chromium/third_party/openmax_dl/dl/sp/src/arm/detect.c
index 57bfe4089..94a3f7ddc 100644
--- a/src/3rdparty/chromium/third_party/openmax_dl/dl/sp/src/arm/detect.c
+++ b/src/3rdparty/chromium/third_party/openmax_dl/dl/sp/src/arm/detect.c
@@ -9,13 +9,57 @@
  *
  */
 
-#include <cpu-features.h>
-
-#include "android/log.h"
 #include "dl/sp/api/omxSP.h"
 
+// For ArmCpuCaps()
+#include <stdio.h>
+#include <string.h>
+
+// based on libvpx arm_cpudetect.c
+static int ArmCpuCaps(const char* cpuinfo_name) {
+  char cpuinfo_line[512];
+  FILE* f = fopen(cpuinfo_name, "r");
+  if (!f) {
+    // Assume Neon if /proc/cpuinfo is unavailable.
+    // This will occur for Chrome sandbox for Pepper or Render process.
+    return 1;
+  }
+  while (fgets(cpuinfo_line, sizeof(cpuinfo_line) - 1, f)) {
+    if (memcmp(cpuinfo_line, "Features", 8) == 0) {
+      char* p = strstr(cpuinfo_line, " neon");
+      if (p && (p[5] == ' ' || p[5] == '\n')) {
+        fclose(f);
+        return 1;
+      }
+      // aarch64 uses asimd for Neon.
+      p = strstr(cpuinfo_line, " asimd");
+      if (p && (p[6] == ' ' || p[6] == '\n')) {
+        fclose(f);
+        return 1;
+      }
+    }
+  }
+  fclose(f);
+  return 0;
+}
+
 int omxSP_HasArmNeon() {
-  return (android_getCpuFeatures() & ANDROID_CPU_ARM_FEATURE_NEON) != 0;
+#if defined(__arm__) || defined(__aarch64__)
+// gcc -mfpu=neon defines __ARM_NEON__
+// __ARM_NEON__ generates code that requires Neon.  NaCL also requires Neon.
+// For Linux, /proc/cpuinfo can be tested but without that assume Neon.
+#if defined(__ARM_NEON__) || defined(__native_client__) || !defined(__linux__)
+  return 1;
+// For aarch64(arm64), /proc/cpuinfo's feature is not complete, e.g. no neon
+// flag in it.
+// So for aarch64, neon enabling is hard coded here.
+#elif defined(__aarch64__)
+  return 1;
+#else
+  // Linux arm parse text file for neon detect.
+  return ArmCpuCaps("/proc/cpuinfo");
+#endif
+#endif  // __arm__
 }
 
 static void SetFFTRoutines() {
@@ -24,13 +68,9 @@ static void SetFFTRoutines() {
    * forward and inverse FFTs
    */
   if (omxSP_HasArmNeon()) {
-    __android_log_print(ANDROID_LOG_INFO, "OpenMAX DL FFT",
-                        "Using NEON FFT");
     omxSP_FFTFwd_RToCCS_F32 = omxSP_FFTFwd_RToCCS_F32_Sfs;
     omxSP_FFTInv_CCSToR_F32 = omxSP_FFTInv_CCSToR_F32_Sfs;
   } else {
-    __android_log_print(ANDROID_LOG_INFO, "OpenMAX DL FFT",
-                        "Using non-NEON FFT");
     omxSP_FFTFwd_RToCCS_F32 = omxSP_FFTFwd_RToCCS_F32_Sfs_vfp;
     omxSP_FFTInv_CCSToR_F32 = omxSP_FFTInv_CCSToR_F32_Sfs_vfp;
   }
-- 
2.13.0

